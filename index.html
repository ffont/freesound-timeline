<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>freesound timeline</title>
		<script type="text/javascript" src="freesound.js"></script>
		<script src="audioengine.js"></script>
		<link href="slider.css" rel="stylesheet">
		<style>
			body {font-family: 'Helvetica', sans-serif; font-size: 12px; color:#333;}
			h1 {font-family: Helvetiva, Arial; font-size:30px;}
			a {color: #F31C36; text-decoration: none;}
			a:visited {color: #F31C36;}
			a:hover {color: #F31C36; text-decoration: underline;}
			input { padding: 5px; border-radius: 4px; border: 1px #ddd solid; font-size: 12px; margin-bottom: 3px;}
			button { 
				height: 24px;
				border-radius: 12px; 
				padding-left: 10px; 
				padding-right: 10px; 
				border: 0px; 
				background-color: #F31C36; 
				color: white; 
				margin: 0px;
				margin-bottom: 3px;
				cursor:pointer;
				font-size: 12px;
			}
			.slider_label {vertical-align: top; line-height: 26px;}
			button:hover {background-color: #f76576; }
			.black_button {background-color: #333; }
			.black_button:hover {background-color: #888; }
			.red_text {color:#F31C36; }
			.gray_text {color:#888; }
			#evolution_percentage_indicator {
				display: none; /* must be set to inline-block in code  */
				width: 100px;
				height: 24px;
				background-color: #ffc9cf;
				vertical-align: top;
				margin-bottom: 5px;
			}
			#evolution_percentage_indicator_loader {
				background-color: #F31C36;
				width: 0%;
				height: 100%;
			}
			@keyframes flash_input {
			    from { background-color: #ffc9cf; }
			    to { background-color: #fff; }
			    
			}
			.flash_input {
			    animation-name: flash_input;
			    animation-duration: 900ms;
			}    
		</style>
	</head>
	<body>
		<script type="text/javascript">

			// Global variables and init

			var soundscape_compleixty = 0.4;
			var soundscape_complexity_interval = 3000;
			var query_page_size = 15;
			var play_timers = [];
			var am = undefined; // Audio manager
			var currentlyPlayedSounds = [];
			var incomingSounds = [];
			var incomingSoundsCopy = [];
			var evolutionTimer = undefined;
			var evolutionCurrentStep = 0;
			var evolutionResolution = 100; // Number of steps per month
			var evolutionTimeInterval = (90 * 1000)/evolutionResolution; // How long it takes for a full month to evolve to the next
			

			window.onload = function(){
				freesound.setToken("d31c795be3f70f7f04b21aeca4c5b48a599db6e9");
				document.getElementById('complexity').value = soundscape_compleixty;

				// Chose random month/year
				var currentYear = (new Date()).getFullYear();
				var oldestYear = 2005;
				var randomYear = oldestYear + parseInt(Math.random() * ((currentYear + 1) - oldestYear), 10)
				var randomMonth = parseInt(Math.random() * 12, 10) + 1;
				if (randomYear === oldestYear){
					if (randomMonth < 3){
						randomMonth = 3;
					}
				} else if (randomYear === currentYear){
					if (randomMonth >= (new Date()).getMonth()){
						randomMonth = (new Date()).getMonth() -1;
					}
				}
				document.getElementById('year').value = randomYear;
				document.getElementById('month').value = randomMonth;

				parseHashAndSetParams();
			};

			function initSoundArrays(){
				currentlyPlayedSounds = [];
				incomingSounds = [];
				incomingSoundsCopy = [];
				play_timers = [];
			}

			// Audio stuff

			function lazyInitAudioManager(){
				// Lazily initialize audio manager
				// We only init audio manager when we really need it (when a sound is to be played)
				// In this way we expect to avoid restrictions in browsers where audio
				// is only played when users have made some interactions
				if (am === undefined) {
					am = initAudioManager();
					document.getElementById('volume').value = 0.5;
					setVolume();
				}
			}

			function playSound(name,url){

				// Only play sound if a random number is above a specific probability, otherwise try
				// again after some time.
				if (Math.random() >= (1.0 - soundscape_compleixty)) {
					clearPlayTimersForSound(url); // Remove existing play timer for this sound (if any)
					document.getElementById("respSearch").innerHTML = "Playing: " + name;
					am.playSoundFromURL(url, 0, {
						panHRTF: {x:randomBetween(-1.0, 1.0), y:randomBetween(-2.0, 2.0), z:randomBetween(-2.0, 2.0) },
						onended: function(event){
							playSound(name, url);  // On end, play again the sound
							// NOTE: we don't use Web Audio API loop prop here as it does not trigger onended event
						}
					});
					if (document.getElementById("panic2").offsetParent !== null){
						document.getElementById("panic2").style.display = 'none';
						document.getElementById("panic1").style.display = 'block';
						document.getElementById("volumeDisplay").style.display = 'block';
					}

				} else {
					var play_timer = setTimeout(function(){
						playSound(name, url);
					}, soundscape_complexity_interval);
					play_timers.push({name: url, timer: play_timer});
				}	
			}

			function playCurrentSounds(){
				// Compare currentlyPlayedSounds and the sounds that are really being played in am:
				
				var currentBufferNodes = am.getAllUniqueBufferNodesList();
				var nAddedToPlay = 0;
				var nRemovedFromPlay = 0;
				
				// 1) add sounds to am which are not really being played but are in currentlyPlayedSounds
				for (i in play_timers){
					currentBufferNodes.push(play_timers[i].name);  // Expand with sound URLs which are waiting to be played in timer
				}
				for (i in currentlyPlayedSounds){
                    var snd = currentlyPlayedSounds[i];
                    var url = snd.previews['preview-hq-mp3']; // ogg seems to fail on safari...
                    if (currentBufferNodes.indexOf(url) === -1){
                    	// If sound not present in buffer, start to play it
                    	var label = '<a href="' + snd.url + '" target="_blank">' + snd.name + '</a> by <b>' + snd.username + '</b>';
                    	playSound(label, url);	
                    	//console.log('Adding sound to play ', url);
                    	nAddedToPlay += 1;
                    }
                }

                // 2) remove sounds from am which are not in currentlyPlayedSounds
                var currentlyPlayedSoundsURLs = currentlyPlayedSounds.map(x => x.previews['preview-hq-mp3']);  // Get currently played sound URLs (useful later)
				
				for (i in currentBufferNodes){
					var name = currentBufferNodes[i];
					if (currentlyPlayedSoundsURLs.indexOf(name) === -1){
						// If buffer not present in sounds, remove it
						am.stopBufferNodesForSound(name, disableOnEnded=true, hardStop=true, removeBuffer=true); // TODO: try to set hard stop to false and see if it makes difference
						//console.log('Removing sound from play ', name);
						nRemovedFromPlay += 1;
					}
				}

				if ((nAddedToPlay > 0) || (nRemovedFromPlay > 0)){
					console.log(nAddedToPlay + ' sound added to play, ' + nRemovedFromPlay + ' removed');	
				}

				// 3) Update attribution list accordingly
				document.getElementById('attributionList').innerHTML = '<span class="gray_text">Sounds used:</span> <br><br>';
				for (i in currentlyPlayedSounds){
                    var snd = currentlyPlayedSounds[i];
                    var label = '<a href="' + snd.url + '" target="_blank">' + snd.name + '</a> by <b>' + snd.username + '</b>';
                    document.getElementById('attributionList').innerHTML += 
                    	label + ' | <a href="' + snd.license + '" target="_blank">' + getLicenseName(snd.license) + '</a><br>'
                }
                
			}

			function clearPlayTimersForSound(url){
				var new_play_timers = [];
				for (var i =0;i<play_timers.length;i++){  
					if (play_timers[i].name === url){
						var timer = play_timers[i].timer;
						clearTimeout(timer);
					} else {
						new_play_timers.push(play_timers[i]);
					}
				}
				play_timers = new_play_timers;
			}

			function stopAllSounds(){

				// Stop all playing audio buffers (if am was ever initialized only)
				am.stopAllBufferNodes(disableOnEnded=true, hardStop=true, removeBuffers=true);	
				
				// Clear all existing timeouts
				for (var i =0;i<play_timers.length;i++){  
					var timer = play_timers[i].timer;
					clearTimeout(timer);
				}
				play_timers = [];

				// Update UI
				document.getElementById("panic1").style.display = 'none';
				document.getElementById("panic2").style.display = 'block';
				document.getElementById("volumeDisplay").style.display = 'none';
				document.getElementById("respSearch").innerHTML = "";
			}

			function softStopAllSounds() {
				// Stop all playing audio buffers (if am was ever initialized only)
				am.stopAllBufferNodes(disableOnEnded=true, hardStop=false, removeBuffers=true);	
				
				// Clear all existing timeouts
				for (var i =0;i<play_timers.length;i++){  
					var timer = play_timers[i].timer;
					clearTimeout(timer);
				}
				play_timers = [];

			}


			// Util functions

			function randomBetween(min, max) {
				// from https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript
			    if (min < 0) {
			        return min + Math.random() * (Math.abs(min)+max);
			    }else {
			        return min + Math.random() * max;
			    }
			}

			function shuffleArray(array) {
				// from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
			    for (var i = array.length - 1; i > 0; i--) {
			        var j = Math.floor(Math.random() * (i + 1));
			        var temp = array[i];
			        array[i] = array[j];
			        array[j] = temp;
			    }
			}

			function parseHashAndSetParams(){
				// Set month, year and popularity measure from hash (if present)
				var hash = window.location.hash;
				hash = hash.slice(1,hash.length).split(',');

				var month = hash[0];
				var year = hash[1];
				var alternative = hash[2];
				var complexity = hash[3];
				var auto_advance = hash[4];
				var evolution_percentage = hash[5];
				
				if ((month !== undefined) && (year !== undefined)){
					document.getElementById('month').value = month;
					document.getElementById('year').value = year;
				}
				if (alternative == 'true') {
					document.getElementById("alternative").checked = true;
				}
				if (complexity) {
					soundscape_compleixty = complexity;
					document.getElementById("complexity").value = soundscape_compleixty;	
				}
				if (evolution_percentage) {
					var newEvolutionCurrentStep = parseInt(evolution_percentage / 100 * evolutionResolution, 10);
					if ((newEvolutionCurrentStep > evolutionResolution) || (newEvolutionCurrentStep < 0)){
						newEvolutionCurrentStep = 0;
					}
					evolutionCurrentStep = newEvolutionCurrentStep;  // Set current evolution step
				}
				if (auto_advance == 'true') {
					document.getElementById("auto_advance").checked = true;	
					displayEvolutionProgress();
				} else {
					hideEvolutionProgress();
				}
			}

			function setHash(){
				var hash = document.getElementById('month').value + ',' + 
						   document.getElementById('year').value + ',' + 
						   document.getElementById('alternative').checked + ',' +
						   document.getElementById('complexity').value + ',' +
						   document.getElementById('auto_advance').checked + ',' +
						   getCurrentEvolutionPercentage();
						   ;
				parent.location.hash = hash;
			}

			function getLicenseName(license_url){
				return {
					'http://creativecommons.org/licenses/by/3.0/': 'CC-BY',
					'http://creativecommons.org/publicdomain/zero/1.0/': 'CC0',
					'http://creativecommons.org/licenses/by-nc/3.0/': 'CC-BY-NC',
					'http://creativecommons.org/licenses/sampling+/1.0/': 'CC-S+',
				}[license_url]

			}

			function getNextMonth(month){
				if (parseInt(month,10) >= 12){
					return "1"
				}else{
					return (parseInt(month,10) + 1).toString()
				}
			}
			
			function getNextYear(year,month){
				if (parseInt(month,10) >= 12){
					return (parseInt(year,10) + 1).toString()
				}else{
					return year
				}
			}
			
			function getPreviousMonth(month){
				if (parseInt(month,10) <= 1){
					return "12"
				}else{
					return (parseInt(month,10) - 1).toString()
				}
			}
			
			function getPreviousYear(year,month){
				if (parseInt(month,10) <= 1){
					return (parseInt(year,10) - 1).toString()
				}else{
					return year
				}
			}

			function getCurrentEvolutionPercentage(){
				return Math.ceil(100 * (evolutionCurrentStep) / evolutionResolution);
			}

			function displayEvolutionProgress(){
				var percentage = getCurrentEvolutionPercentage();
				// If evolution is active
				document.getElementById('evolution_percentage_indicator').style.display = 'inline-block';
				document.getElementById('evolution_percentage_indicator_loader').style.width = parseInt(percentage, 10) + '%';
			}

			function hideEvolutionProgress(){
				document.getElementById('evolution_percentage_indicator').style.display = 'none';
			}

			function displayFlashNextMonth(){
				// Input elements need to be removed and re-added for the flash effect to work every time
				// See: https://css-tricks.com/restart-css-animation/

				var month_input = document.getElementById('month');
				var new_month_input = month_input.cloneNode(true);
				month_input.parentNode.replaceChild(new_month_input, month_input);
				document.getElementById('month').classList.add('flash_input');

				var year_input = document.getElementById('year');
				var new_year_input = year_input.cloneNode(true);
				year_input.parentNode.replaceChild(new_year_input, year_input);
				document.getElementById('year').classList.add('flash_input');
			}


			// Button interactions

			function play(){
				document.getElementById('attributionList').innerHTML = '';
				lazyInitAudioManager(); // Init audio context here in response to user action
				stopAllSounds();
				initSoundArrays();
				setHash();

				// Get sounds for current month
				var month = document.getElementById('month').value;
				var year = document.getElementById('year').value;
				search(month, year, function(data){
	            	sounds = data.results;
	            	if (data.results.length === 0) {
	            		document.getElementById("respSearch").innerHTML = "No results...";
	            	} else {
	            		document.getElementById("respSearch").innerHTML = "Loading sounds... will begin playing at any moment...";
		            	shuffleArray(sounds);
						currentlyPlayedSounds = sounds;
						playCurrentSounds();
		            	if (document.getElementById('auto_advance').checked){
		            		startEvolution(); // Start when we receive first sounds	
		            	}	
	            	}
		        });

				// Get sounds for next month
				var next_month = getNextMonth(month);
				var next_year = getNextYear(year, month);
		        search(next_month, next_year, function(data){
		        	if (data.results.length === 0) {
	            		document.getElementById("respSearch").innerHTML = "No results...";
	            	} else {
		            	sounds = data.results;
						shuffleArray(sounds);
		            	incomingSounds = sounds;
		            	incomingSoundsCopy = incomingSounds; // Store a copy of all original incoming sounds for later use	                
		            }
		        });
			}

			function next(){
				var month = document.getElementById('month').value;
				var year = document.getElementById('year').value;
				document.getElementById('month').value = getNextMonth(month);
				document.getElementById('year').value = getNextYear(year,month);
				displayFlashNextMonth();
				setHash();
				if (evolutionTimer !== undefined) {
					// If evolution is running stop it and set step to 0
					stopEvolution();
					hideEvolutionProgress();
				}
				evolutionCurrentStep = 0;
				play();
			}
			
			function previous(){
				var month = document.getElementById('month').value;
				var year = document.getElementById('year').value;
				document.getElementById('month').value = getPreviousMonth(month);
				document.getElementById('year').value = getPreviousYear(year,month);
				displayFlashNextMonth();
				setHash();
				if (evolutionTimer !== undefined) {
					// If evolution is running stop it and set step to 0
					stopEvolution();
					hideEvolutionProgress();
				}
				evolutionCurrentStep = 0;
				play();
			}

			function setComplexity(){
				var value = document.getElementById('complexity').value;
				soundscape_compleixty = value;
				setHash();
			}

			function setVolume(){
				value = document.getElementById('volume').value;	
				am.setMainVolume(value);
			}

			function setAutoAdvance(){
				var autoAdvance = document.getElementById('auto_advance').checked;
				var isRunning = evolutionTimer !== undefined;
				if (!autoAdvance){
					if (isRunning){
						stopEvolution();
					}
					hideEvolutionProgress();
				} else {
					if (currentlyPlayedSounds.length > 0){
						// If sounds are being played, start evolution now
						startEvolution();
					}
					displayEvolutionProgress();
				}
				setHash();
			}

			function setPopularityMeasure(){
				// The popularity measure is used when new sounds are searched in Freesound.
				// However, if we are in "auto advance" mode and there are incoming sounds, we can
				// do a search and replace the sounds in incoming with new sounds retrieved with the
				// the newly set popularity measure

				if (incomingSounds) {
					var month = document.getElementById('month').value;
					var year = document.getElementById('year').value;
					var next_month = getNextMonth(month);
					var next_year = getNextYear(year, month);
			        search(next_month, next_year, function(data){
			        	if (data.results.length === 0) {
		            		document.getElementById("respSearch").innerHTML = "No results...";
		            	} else {
			            	// Chose new sounds to replace incoming sounds
			            	sounds = data.results;
							shuffleArray(sounds);
							var newlyChosenSounds = sounds.slice(0, incomingSounds.length);

							// Update incomingSoundsCopy with the new sounds
							// Iterate over existing incomingSoundsCopy and remove those that have not yet been added to currentlyPlayedSounds
							var newIncomingSoundsCopy = [];
							var currentlyPlayedSoundsURLs = currentlyPlayedSounds.map(x => x.url);
			            	for (i in incomingSoundsCopy){
			            		var incomingSound = incomingSoundsCopy[i];
			            		if (currentlyPlayedSoundsURLs.indexOf(incomingSound.url) > -1){
			            			newIncomingSoundsCopy.push(incomingSound);
			            		}
			            	}
			            	// Now add the newly retrieved sounds
			            	newIncomingSoundsCopy = newIncomingSoundsCopy.concat(newlyChosenSounds);
			            	incomingSoundsCopy = newIncomingSoundsCopy;

			            	// Update incoming sounds
			            	incomingSounds = newlyChosenSounds;
			            }
			        });
				}

				setHash();  // Update hash
			}

			function panic(){
				if (evolutionTimer !== undefined){
					stopEvolution();
				}
				stopAllSounds();
				initSoundArrays();
			}

			// Search and interaction with Freesound

			function search(month, year, onSuccess, onFailure){

				var q = "";
				var p = 1;
				var fields = "id,name,previews,username,license,url"
				var s = "rating_desc"; // Default is by ratings
				if (document.getElementById('alternative').checked){ s = "downloads_desc"; }

				var next_month = getNextMonth(month);
				var next_year = getNextYear(year, month);
				var f = "created:[" + year + "-" + month + "-1T00:00:00Z TO " + next_year + "-" + next_month + "-01T00:00:00Z] duration:[0.0 TO 60]";

				freesound.textSearch(q, {page:p, filter:f, sort:s, fields:fields, page_size:query_page_size},
		            function(data){
		            	// Process successful response
		            	onSuccess(data);
		            },function(){ 
		            	// Process error response
		            	document.getElementById("respSearch").innerHTML = "Error while searching..."; 
		            	if (onFailure !== undefined){
		            		onFailure();	
		            	}
		            }
		        );
				document.getElementById("respSearch").innerHTML = "Waiting for results...";
			}

			// Evolution

			function step() {

				var month = document.getElementById('month').value;
				var year = document.getElementById('year').value;
				var monthProgress = 100 * (evolutionCurrentStep + 1) / evolutionResolution;				

				// Update currentlyPlayedSounds by adding some from incomingSounds
				var madeAnyChanges = false;
				if (evolutionCurrentStep > 0){
					if ((currentlyPlayedSounds.length > 0) && (incomingSounds.length > 0)){ // If there are still sounds to be added
						
						var soundsShouldHaveBeenAdded = Math.floor(monthProgress / 100 * incomingSoundsCopy.length);
						var soundsHaveBeenAdded = incomingSoundsCopy.length - incomingSounds.length;
						var nSoundsToAdd = soundsShouldHaveBeenAdded - soundsHaveBeenAdded

						for (var i=0; i<nSoundsToAdd; i++){
							// Remove one sound from the top of currentlyPlayedSounds, add one sound from incoming at the end
							currentlyPlayedSounds = currentlyPlayedSounds.slice(1, currentlyPlayedSounds.length);
							currentlyPlayedSounds.push(incomingSounds[0]);
							incomingSounds = incomingSounds.slice(1, incomingSounds.length);
						}

						if (nSoundsToAdd > 0){
							console.log('Moved ' + nSoundsToAdd + ' sounds from incoming to current');
							madeAnyChanges = true;
						}
					}
				}

				// Update audio players, etc.
				if (madeAnyChanges) {
					playCurrentSounds();	
				}

				if (evolutionCurrentStep >= (evolutionResolution - 1)){  // Last step
					// Advance 1 month
					var next_month = getNextMonth(month);
					var next_year = getNextYear(year, month);
					document.getElementById('month').value = next_month;
					document.getElementById('year').value = next_year;
					displayFlashNextMonth();

					// Check if we are in the future and should stop
					var currentRealYear = (new Date()).getFullYear();
					if (next_year >= currentRealYear){
						if (next_year > currentRealYear){
							stopEvolution();
							displayEvolutionProgress();
							softStopAllSounds();
							document.getElementById("respSearch").innerHTML = "No sounds for the future (yet)...";
							setHash(); // Update hash in URL
							return 0;
						} else {
							// next_year === currentRealYear
							var currentRealMonth = (new Date()).getMonth();
							if (next_month > currentRealMonth){
								stopEvolution();
								displayEvolutionProgress();
								softStopAllSounds();
								document.getElementById("respSearch").innerHTML = "No sounds for the future (yet)...";
								return 0;
							}
						}
					}

					// Set currentlyPlayedSounds to incomingSoundsCopy (just in case it had not been fully updated after all the steps)
					currentlyPlayedSounds = incomingSoundsCopy;
					incomingSounds = [];
					incomingSoundsCopy = [];

					// Search new sounds and store in incoming
					var month = document.getElementById('month').value;
					var year = document.getElementById('year').value;
					var next_month = getNextMonth(month);
					var next_year = getNextYear(year, month);
					search(next_month, next_year, function(data){
						sounds = data.results;
						shuffleArray(sounds);
						incomingSounds = sounds;
						incomingSoundsCopy = incomingSounds; // Store a copy of all original incoming sounds for later use
					});
					evolutionCurrentStep = 0; // Restart step counter
				} else {
					evolutionCurrentStep += 1; // Advance step
				}

				displayEvolutionProgress();
				setHash(); // Update hash in URL

				// Schedule next step
				evolutionTimer = setTimeout(function(){
					step();
				}, evolutionTimeInterval);
			}

			function startEvolution(){
				displayEvolutionProgress();
				evolutionTimer = setTimeout(function(){
					step();
				}, evolutionTimeInterval);
			}

			function stopEvolution(){
				clearTimeout(evolutionTimer);
				evolutionTimer = undefined;
			}

		</script>
		<br>
		<h1 style="text-align: center">free<span class="red_text">sound</span> timeline</h1>
		<div style="text-align:center;">
			<p>
				enter month (1-12): <input type="text" id="month" value="3" size=2 maxlength=2 onchange="setHash()">
				<br>
				enter year (2005-now): <input type="text" id="year" value="2005" size=4 maxlength=4 onchange="setHash()">
				<br>
				<span class="slider_label">density:</span> <input id="complexity" type="range" min=0.05 max=1.0 step='.05' value=1.0 oninput="setComplexity()" onchange="setComplexity()">
				<br>
				use alternative popularity measure: <input type="checkbox" id="alternative" onchange="setPopularityMeasure()">
			</p>
			
			<div>
				<button id="search" onclick="play()">play!</button>
				<div id="evolution_percentage_indicator"><div id="evolution_percentage_indicator_loader"></div></div>
				auto advance: <input type="checkbox" checked onchange="setAutoAdvance();" id="auto_advance">
				<br>
				<button onclick="previous()"><<</button>
				<button onclick="next()">>></button>
			</div>
			
			<br><div> 
				<span id="respSearch">please <b>use headphones</b> for the full experience</span>
				<div id="volumeDisplay" style="display:none;"><span class="slider_label">volume:</span> <input id="volume" type="range" min=0.0 max=1.0 step='.05' value=1.0 oninput="setVolume()" onchange="setVolume()"></div>
			</div>
			<br>
				<div id="panic1" style="display:none"><button id="stopAllSounds" class="black_button" onclick="panic()">panic!</button></div>
				<div id="panic2">no need for panic button... yet!</div>
			<br>
			<div id="attributionList"></div>
			<br>
			<br>
			<div style="max-width:800px;display:inline-block;" class="gray_text">	
				This is a very simple hack that gets the most popular sounds in <a href="https://freesound.org" target="_blank">Freesound</a> for a given
				year and month and plays them all at once (in loop). Use the density slider to adjust the complexity of the generated soundscape. Copy the URL to share the soundscape with your friends. <br><b>EDIT</b>: added a new killer feature which allows you to automatically advance in time and explore Freesound history in a sort of "radio" mode. Just check the "auto-advance" checkbox and enjoy.

				<br><br>This hack was originally implemented in 2011 when I was starting to learn about web technologies. It has been recently updated to use Freesound APIv2, the Web Audio API (including random HRTF panning for each sound!) and to include some other nice improvements. Want to contribute? visit the <a href="http://github.com/ffont/freesound-timeline" target="_blank">code repository</a>.
			</div>
		</div>
	</body>
</html>
